# STM32-学习笔记

介绍

这篇文章是我入门嵌入式的文章，有些理解可能不足。

是看江协和正点原子的视频，板子是STM32F103C8T6最小系统板。
正点为主：[第3讲 STM32学习方法_视频说明_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Rx411R75t?p=3&vd_source=1a07d5f9a611dfcab66b26946efdfc4d)

江协为辅：[https://www.bilibili.com/video/BV1th411z7sn?vd_source=6dd64b24a2e3d6b6b1641e4f3a6e874a](https://www.bilibili.com/video/BV1th411z7sn?vd_source=6dd64b24a2e3d6b6b1641e4f3a6e874a)

这些是我在学习STM32F103C8T6的过程中自己的学习过程，以及练习和总结的个人笔记。

正在更新，

**大家可以在[我的gitee仓库](https://gitee.com/Xiao____liu/learn-STM32) 中下载笔记源文件、梁山派资料等**

**笔记源文件可以在Notion中导入**

# 0.资料准备

1. [芯片包的下载](http://www.keil.com/)
2. [数据手册和参考手册](https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html)
3. [STM32标准外设库下载](https://www.st.com/en/embedded-software/stm32-standard-peripheral-libraries.html)

# 1.[江协] 创建标准库的工程模板

这一部分只是创建了一个基础的标准库模板。并没有Hardware等文件

## 1.解压库函数的压缩包并打开

库函数为：`STM32F10x_StdPeriph_Lib_V3.5.0`，这个可以去官网下载。

解压后文件夹内容如下

- Libraries是库函数的文件
- Project是官方提供的工程示例和模板
- Utilities是官方做的一个小电路板，存放的用来测评stm32的程序
- Release_Notes.html是发布文档
- stm32f10x_stdperiph_lib_um.chm为库函数使用手册

## 2.建立工程模板，尝试使用寄存器/标准库来点灯

**本章建立了工程模板**。**并尝试用寄存器和库函数来进行点灯操作**

建立工程模板是为了配置好STM32的环境，并且方便下次去建立工程。不用每次都新建一次。

1. 建立工程文件是为了方便管理。可以起名为`STM32Project`
2. 在Keil上新建工程，起名后  选择芯片型号（这里为STM32F103C8）

### 一、添加Start启动文件夹

1. 新建Start文件，用来存放STM32的启动文件，STM32运行时会先运行它们
    
    启动文件的存放位置位于库函数的压缩包中的Libraries文件中。下面的位置可以参考用
    
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm`
    
    **我们把这里面的所有文件都粘贴到Start文件中。**
    
    往回走，可以在这个目录下找到一些头文件
    
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\**DeviceSupport**\ST\STM32F10x`
    
    - stm32f10x.h  -  STM32寄存器外设描述文件，是用来描述stm32有哪些寄存器，和他对应的地址
    - system_stm32f10x.c    -    这两个`system_stm32f10x`文件主要是用来配置时钟的（STM32的72MHZ主频就是在这里配置的）
    - system_stm32f10x.h    。
    
    **上面三个同上，也是全部放到Start文件中**
    
    因为STM32是内核和内核外围的设备组成的，并且内核寄存器描述和外围寄存器描述是不在一起的，所以要添加内核寄存器的描述文件
    
    这次就不是打开`D**eviceSupport`** 文件了，而是打开内核的**`CoreSupport`**文件
    
    - core_cm3.c  -  这两个就是内核的寄存器描述文件.h以及配置文件.c
    - core_cm3.h
2. Keil添加启动文件Start。`.s`的启动文件只需要添加一个。但他有分类
    
    
    所以我们选择`_md.s`后缀的文件
    
    添加后再把其他的.c  .h后缀的文件都添加进来（要选择筛选为ALL，否则看不全）
    
3. 在工程选项中添加文件的路径，否则找不到。
并且这样也有利于移动文件，因为添加后工程是以目录所在的文件位置去找文件，而不是使用绝对路径去找。可以很方便的打包工程发给别人
    1. 打开魔术棒，在C/C++选项中找到Include Paths的框框，点三个点找到Start的文件夹。然后确定。

### 二、添加User用户文件夹

1. 在工程模板的文件夹下添加User文件夹，用来存放用户写的代码
2. 在Keil软件的Start的上一个目录Target 1上右键，点击添加组。然后重命名为Start。
并在魔术棒→  C/C++中，添加好头文件路径 Include Path 
3. Keil软件上右键Start添加新文件，选择.c输入ain.c文件然后选择存放路径到User文件中，否则会默认放到文件夹外的工程目录中。
    
    （这里我已经在魔术棒上设置好Tab=4个空格和显示空格等配置了。）
    （并且魔术棒按钮的Target块中选择的是ARMCode编译器为v5.06）
    （在扳手工具处已经设置字号为14，编码格式为：GB2312）
    
4. 在里边输入
    
    ```c
    #include "stm32f10x.h"  //头文件
    
    int main()
    {
        while(1)
        {
        
        }
    }
    //注意最后一行得多一行空格，不然编译会报错。
    ```
    
    此时编译（编译分为全局编译和单文件编译，全局编译是对所有文件编译，单文件则是对当下的文件进行编译。这里先选择单文件就够了）就可以看到0错误0警告。
    
5. 把STINK和系统板插好，然后连接电脑。
- 3.3V对应3.3V
- GND对应GND
- SWDIO对应SWDIO
- SWCLK对应SWCLK
1. 点击魔术棒选择Debug，设置Use为STink调试器（ST-Link Debugger），然后点击右边的设置按钮。在flash下载的选项中，把Reset and Run 勾选上，这样每次下载程序后会自动复位并执行，不需要按复位按键了
    
    （这里我已经下载好虚拟串口的驱动CH340了，不下是发现不了设备的）
    
2. 编译一下，可以看到0警告0错误

### 三、尝试用寄存器点亮LED灯

**当弄到现在，创建好User文件夹对于寄存器开发者来说，已经建立好工程模板了。**

> **可以先尝试一下寄存器点灯**
> 

这里我点的灯位于GPIOC，

寄存器点灯只需要配置三个寄存器。

1. **首先是配置RCC寄存器，使能GPIOC的时钟，**
要使能GPIOC的时钟。而GPIO是挂载到APB2的总线上的。
    
    打开STM32F10xxx参考手册（中文）手册后可以看到IOPC是在RCC_APB2ENR总线上（偏移地址：0x18）的第4位控制。并且下面有说明这一项为1就开启。
    
    所以把这一项写1就可以开启他的时钟了。
    
    整个寄存器的2进制数据换成16进制就是0 0 0 0    0 0 1 0
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled.png)
    
    **所以写上代码`RCC->APB2ENR = 0x00000010;`就可以打开GPIOC的时钟了。**
    
2. 然后第二个寄存器，要配置PC13的端口的模式
    
    在手册中的通用和复用I/O中可以找到GOIO寄存器的一小节。在里面找到**端口配置高寄存器（GPIOx_CRH）**的一小节。
    (0-7的前八位是在低寄存器里，8-15是在高寄存器里配置)
    其中的CNF13 和MODE13就是用来配置端口PC13的
    
    这里我们需要将端口配置为 通用推挽输出模式也就是CNF13的两位要为**00**，
    MODE则是设置为输出模式，最大速度为50MHZ,也就是MODE两位要为**11**
    
    最后按照16进制，把32位二进制位转换为16进制的数字
    也就是把0 0 3 0   0 0 0 0 
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%201.png)
    
    **所以写上代码`GPIOC->CRH = 0x00300000;`就配置PC13口为推挽输出模式，速度为50MHz了**
    
3. 下一步就是配置端口输出数据寄存器
    
    在手册中的通用和复用I/O中可以找到GOIO寄存器的一小节。
    在里面找到**端口输出数据寄存器（GPIOx_ODR）**的一小节。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%202.png)
    
    这一位写一就是把PC13的输出设置为高电平了。
    
    把这32位2进制换算为16进制，就是0 0 0 0   2 0 0 0 
    
    **所以写上代码`GPIOC->ODR = 0x00002000;`就配置PC13口为高电平**
    
    因为这个板子的灯是低电平点亮，所以配置为全0就能点亮灯了**`GPIOC->ODR = 0x00000000;`**
    下边那个灯就是我点亮的。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled.jpeg)
    
    > 可以看到寄存器点灯十分的麻烦，得去手册查寄存器。而寄存器那么多，根本不可能记得完。并且我刚才点灯是把除了PC13之外的位都设置成了0。,这样会影响其他端口的正常配置，如果要不影响的话还得用&=或者|=。就会更加麻烦。所以寄存器的操作方式，虽然代码简洁，但是操作起来很不方便
    
    下面我就要去学习库函数的使用，来用库函数点灯！！
    > 

### ***、尝试用库函数来点亮LED灯

### 四、添加Library文件

**本章添加了库函数到Library文件，并在Keil软件中定义了库函数头文件。**

Library是用来存放库函数的，让我们可以使用。

1. 在工程目录新建Library的文件夹。
2. 添加库函数到新建的Library文件
    
    库函数位于库函数压缩包的目录为：**`\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\src`** 中了。其中`STM32F10x_StdPeriph_Lib_V3.5.0` 为STM公司推出的标准外设库。
    
    其中的文件就是库函数的源文件了。
    
    misc.c  为内核的库函数。其余的都是内核外的外设库函数。
    这里就Ctrl+A全选，全部复制到Library文件夹中
    
    然后再打开固件库的inc文件夹，目录就在上一级。
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\inc`
    
    这个文件夹中放的是库函数的头文件，也把他复制到Library文件夹中。
    
3. 接着回到keil软件，在target 1 处右键，添加组，重命名，然后添加文件到组
    
    > 但是到这里，对于库函数来说还是不能直接使用的，需要再添加三个文件
    它位于固件库目录的：**`\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template`**
    > 
    
    可以看到几个文件
    
    - stm32f10x_conf  -  用来配置库函数头文件的包含关系，还有用来参数检查的函数定义，这是所有库函数都需要的
    - 剩下的两个it后缀的是用来存放中断函数的
    
    把这三个文件放到User的目录中。接着在keil软件的User组中添加这三个文件。**并在魔术棒→  C/C++中，添加好头文件路径 Include Path** 
    
4. 完成后，就需要添加库函数的头文件了。
    
    先对`#include "stm32f10x.h"` 的`stm32f10x.h` 右键，选择打开`stm32f10x.h` 滑到最下边可以看到这样一段代码：
    
    ```c
    #ifdef USE_STDPERIPH_DRIVER
      #include "stm32f10x_conf.h"
    #endif
    ```
    
    这是C语言中的条件编译语句，意思是如果我定义了`USE_STDPERIPH_DRIVER`。下面的这个`#include "stm32f10x_conf.h"`才有效
    
    这需要我们点击魔术棒按钮，在C/C++的选项中，在Define框框中输入`USE_STDPERIPH_DRIVER` 这样才能包含标准库函数。
    
    （记得把每个组（文件）的路径添加好头文件路径 Include Path，在魔术棒的C/C++ 中）
    
    可以在KEil软件看到。
    User中的文件，我们是可以修改的，而Start和Library文件中的东西都带有小钥匙
    是改不了的。我们可以点击魔术棒旁边的小箱子来拖动挑中左边的组的排序位置。
    
    比如把User放到最下边，其他放上边，这样的话平时不用就可以收起来。
    
    下面再编译一下就可以看到成功了。
    （单文件编译，如果新添加了文件会默认使用全局编译一次。所以比较慢）
    

### 五、使用库函数进行点灯操作

**本小节使用库函数进行点灯。**

库函数本质还是配置寄存器，不过是间接的了。

1. 第一步还是使能GOIOC的时钟
它位于APB2的外设上。
    
    库函数中用来开启时钟的函数是`RCC_APB2PeriphClockCmd` 
    大概翻译一下就是RCC_APB2  外设  时钟  命令（控制）
    
    输入完后会提示出来这个函数要输入两个参数。
    
    **可以在编译后按F12或者右键跳到函数定义来看他的参数需要填什么，都会有介绍。**
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%203.png)
    
    简介中会说，这个函数是让APB2的时钟使能或者失能的。他的参数可以是下面这些。
    
    **我们这里用的是`RCC_APB2Periph_GPIOC` 这一项，然后填写到函数的第一个参数就OK**
    
    **第二个参数是`ENABLE` 使能。**
    
    **这样就可以使能GPIOC的时钟了。**
    
    通过F12下这个函数，来查看这个函数的内部代码。其实他只是包装了一下。实际上还是配置寄存器的。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%204.png)
    
2. 第二步还是配置端口的模式。
    
    这里用的库函数是`GPIO_Init`，F12查看定义，可以知道他的两个参数
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%205.png)
    
    第一个参数是选择GPIO。x可以是A-G中的数字
    所以第一个参数就是GPIOC。
    
    第二个参数是一个`GPIO_InitTypeDef` 的结构体**的指针（是指针！）**。我们需要先定义一个结构体。结构体的名字根据官方的推荐，最好叫`GPIO_InitStructure。`
    
    代码：`GPIO_InitTypeDef GPIO_InitStructure;`
    
    然后复制结构体的名字，用 `.`  操作符来配置结构体内部的变量。
    
    ```c
        GPIO_InitTypeDef GPIO_InitStructure;
        GPIO_InitStructure.GPIO_Mode = 
        GPIO_InitStructure.GPIO_Pin = 
        GPIO_InitStructure.GPIO_Speed = 
    ```
    
    > 这里可以现在Mode的一行按F12 ，跳转到Mode参数的定义。
    > 
    
    他说：Mode的值在`GPIOMode_TypeDef`（这是一个枚举变量）里可以找到。那么就可以在当前文件Ctrl+F搜一下。找到GPIOMode_TypeDef这个枚举变量的位置。
    这里我们用到的是`GPIO_Mode_Out_PP` ：通用推挽输出。
    然后把这个参数放到Mode = 后就可以了。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%206.png)
    
    > 下面就是配置GPIO_Pin的参数了,
    > 
    
    在使用F12跳转的时候，会显示一个框，这是因为他的定义后很多个。
    这里需要的是member这一项，双击就可跳转过去了。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%207.png)
    
    （其实还是刚才GPIO_Mode跳转过去的那个位置）
    
    他说Pin的值在`GPIO_pins_define`（这是一个枚举变量）里可以找到
    
    仍然是Ctrl+F搜一下。
    
    可以看到这里是#define的宏定义列表
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%208.png)
    
    这里我们需要用到的是GPIO_Pin_13
    
    仍然是复制粘贴过去
    
    > Speed的参数也是同理
    > 
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%209.png)
    
    这里选择`GPIO_Speed_50MHz`
    
    致此，我们定义的结构体变量`GPIO_InitTypeDef GPIO_InitStructure;`的参数就配置完全了。
    下面就可以把结构体变量的**地址（是传地址！！）**放到配置GPIO模式的函数`GPIO_Init` 的第二个参数中了。
    
    ```c
        //配置PC13的端口为推挽输出模式，速度为50MHz
        GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        
        GPIO_Init(GPIOC,&GPIO_InitStructure);//GPIO_Init，配置GPIO模式
    ```
    
3. 第三步：配置GPIO口为高/低电平
    
    这里用到的函数是
    `GPIO_SetBits`  - 设置GPIO为高电平
    `GPIO_ResetBits`  -  设置GPIO为低电平
    
    参数则都是GPIOx，GPIO_Pin_x
    要看定义也是同上F12
    
4. 编译！！
    
    代码如下，如果编译的时候报错：
    
    ```c
    User\main.c(15): error:  #268: declaration may not appear after executable statement in block
    GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
    ```
    
    他的意思这一行的声明位置。C 语言要求变量声明通常应在可执行语句之前。这违反了 C 语言的语法规则，想让我把`GPIO_InitTypeDef GPIO_InitStructure;` 放到第一行声明。我能听他的？
    
    **解决办法就是：在魔术棒→ C/C++处勾选C99Mode（C语言的C99标准）**，这样就不会报错了。
    
    ```c
        //库函数点灯
        
        //打开GPIOC的时钟
        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
        
        //配置PC13的端口为推挽输出模式，速度为50MHz
        GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        
        GPIO_Init(GPIOC,&GPIO_InitStructure);//GPIO_Init，配置GPIO模式
        //设置PC 13为低电平。点灯。
        GPIO_ResetBits(GPIOC,GPIO_Pin_13);
    ```
    
    点灯如下：
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%201.jpeg)
    

# 2.GPIO的工作原理

GPIO如果只是单独的进行输入输出就太浪费了。所以芯片的GPIO口还可以复用为外设功能引脚（比如串口）

GPIO的4种输入模式

- 输入浮空 **GPIO_Mode_IN_FLOATING**
- 输入上拉 **GPIO_Mode_IPU**
- 输入下拉 **GPIO_Mode_IPD**
- 模拟输入 **GPIO_Mode_AIN**

GPIO的4种输出模式

- 开漏输出（带上拉或者下拉）   **GPIO_Mode_Out_OD**
- 开漏复用功能（带上拉或者下拉）**GPIO_Mode_AF_OD**
- 推挽式输出（带上拉或者下拉） **GPIO_Mode_Out_PP**
- 推挽式复用功能（带上拉或者下拉）**GPIO_Mode_AF_PP**

4种最大输出速度（这里与F1不同）

- 2M
- 25M
- 50M
- 100M

**F4的**芯片手册中，GPIo表格只要有FT标识，就代表他可以容忍5V的输入

**F4与F1的不同就是这里的上下拉电阻被移动到了保护二极管那边，而不是在里边。**

![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%202.jpeg)

1. 浮空输入模式：
    
    既不上拉又不下拉，输入信号直接经过施密特触发器，然后存入寄存器，让芯片读取
    
2. 输入上/下拉模式
    
    区别就是输入电平会经过上拉或者下拉电阻拉高或拉低
    
3. 模拟输入
    
    此时不**经过施密特触发器**来转换为高低电平。是跳过触发器直接到AD（A是模拟，D是数字）这里
    
4. 开漏输出
    
    输出强低电平。
    
    输出时，首先是操作位设置寄存器（间接去操作输出数据寄存器）或者输出数据寄存器。然后通过输出控制电路来控制Nmos管是否接地，当输出控制电路输出1时，Nmos为断开，此时的GPIO为高阻态，如果想输出高电平。，就需要配置电阻为上拉。简单来说，开漏输出只可以输出强低电平，高电平得靠外部电阻拉高。显然，这种输出方式就有一个优点，由于高电平完全由外部电阻控制，那此模式下的输出电平是可以通过改变电阻而改变的
    
5. 开漏复用功能
    
    通过复用功能外设来控制输入输出，不是那俩寄存器。其他的都是一样的
    
6. 推挽输出
    
    输出强高低电平。
    
    输出时，首先是操作位设置寄存器（间接去操作输出数据寄存器）或者输出数据寄存器。然后通过输出控制电路来控制两个NMOS管的通断，来控制输出的高低电平。他也可以去配置上下拉电阻，
    
7. 推挽式复用功能
    
    通过复用功能外设来控制输入输出，不是那俩寄存器。其他的都是一样的
    
    **每组（16个IO口）GPIO端口的寄存器包括:**
    
    - 4个32位配置寄存器
        - 1个端口模式寄存器(GPIOx MODER)
        - 1个端口输出类型寄存器(GPIOx OTYPER)
        - 1个端口输出速度寄存器(GPIOx OSPEEDR)
        - 1个端口上拉下拉寄存器(GPIOx PUPDR)
    - 2个32位数据寄存器
        - 1个端口输入数据寄存器(GPIOx IDR)
        - 1个端口输出数据寄存器(GPIOx ODR)
    - 1个端口置位/复位寄存器(GPIOx BSRR)
    - 1个端口配置锁存寄存器(GPIOx LCKR)
    - 两个复位功能寄存器(低位GPIOx AFRL & GPIOx AFRH)  （这个比较重要）
    
    所有的IO口都可以用作中断的输入
    

# 3.[正点] 标准库的LED跑马灯

这里的工程文件，我是用的是江协的工程文件，在其基础上添加了Hardware文件夹和Delay文件夹

并在Keil中添加和保存文件相对路径。

代码如下：

`main.c：`

```c
#include "stm32f10x.h"                  // Device header
#include "led.h"
#include "delay.h"//直接拿的延时函数
int main()
{

    
    LED_Init();//初始化LED

    while(1)
    {
        GPIO_SetBits(GPIOB,GPIO_Pin_15);//PB15为高电平，熄灭
        GPIO_ResetBits(GPIOB,GPIO_Pin_12);//PB12为低电平，点亮
        Delay_ms(500);//延时500ms
        GPIO_SetBits(GPIOB,GPIO_Pin_12);//PB12为高电平，熄灭
        GPIO_ResetBits(GPIOB,GPIO_Pin_13);//PB13为低电平，点亮
        Delay_ms(500);//延时500ms
        GPIO_SetBits(GPIOB,GPIO_Pin_13);//PB13为高电平，熄灭
        GPIO_ResetBits(GPIOB,GPIO_Pin_14);//PB14为低电平，点亮
        Delay_ms(500);//延时500ms
        GPIO_SetBits(GPIOB,GPIO_Pin_14);//PB14为高电平，熄灭
        GPIO_ResetBits(GPIOB,GPIO_Pin_15);//PB15为低电平，点亮
        Delay_ms(500);//延时500ms
    }
}

```

`LED.c`：

```c
#include "led.h"
#include "stm32f10x.h"

void LED_Init(void)
{
    //跑马灯引脚为PB 12 13 14 15,LED为低电平有效
    
        
    //F4的芯片在这里还需要配置上下拉电阻PuPd 以及 推挽或者开漏Otype
    
    //打开GPIOB的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
    //定义GPIO_Init的第二个参数：结构体变量
    GPIO_InitTypeDef GPIO_InitStructure;                
    //↑在C99下不需要放到第第一行
    
    
    //下面的GPIO是分开配置的，其实可以写成A||B.这样就不用写那么多次了。这里我就不改了
    
    
    //PB12
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    //配置PC13的端口为推挽输出模式，速度为50MHz
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);//GPIO_Init，初始化GPIO B，PB12的GPIO
    GPIO_SetBits(GPIOB,GPIO_Pin_12);//设置GPIO为高电平。LED为熄灭
    //
    
   //PB13
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_13);
    
   //PB14
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_14);
    
    
   //PB15
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_15);

}

```

`LED.h`

```c
#ifndef __LED_H //条件编译

#define __LED_H

void LED_Init(void);//初始化LED

#endif

```

Delay.c就不写上去了。

结果如图

![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled.gif)

# 4.[正点]标准库的按键点灯

按键检测使用的是gpio的输入功能。函数为

`KEY1 GPIO_ReadInputDataBit(GPIO_B,GPIO_PIN_11)//读取 GPIOB 11引脚的电平`

## 按键支持连续按的一般思路

支持连续按，每次检测只要是按下的状态都会返回有效值
思路如下：

```c
uint8_t KEY_Scan(void)
{
    if(KEY按下)
    {
        delay(10)//延迟10ms，消抖
        if(KEY按下)//确定按下
        {
            return 有效值
        }
    }
    return 0;//否则返回无效值
}
```

## 按键不支持连续按的一般思路

不支持连续按，按下按键后只要不松开就不会返回有效值
思路如下:
使用了static静态修饰变量

1. 存储持续性：`static` 修饰的局部变量具有静态存储持续性，它在程序的整个运行期间都存在，而不是在函数调用结束时被销毁。
    - 例如，每次函数调用结束后，`static` 局部变量的值会被保留，下次函数调用时会继续使用上次修改后的值。
2. 初始化：只在第一次函数调用时进行初始化。
- 假设一个函数被多次调用，但`static` 局部变量只会在第一次调用时被初始化为指定的值，后续调用不会再次初始化。
1. 作用域：作用域仍然局限在声明它的函数内部，在函数外部无法直接访问。

```c
uint8_t KEY_Scan(void)
{
    static key_up = 1//=1表示上一个状态为未被按下
    if(key_up && KEY按下)//如果上个状态未被按下，并且现在KEY按下，那么就进入。
    {
        delay(10)//延迟10ms，消抖
       
        if(KEY按下)//确定按下
        {
            key_up = 0;//标记KEY按下
            return 有效值
        }
    }
    else if (KEY没有按下)
    {
        key_up = 1;//记录上个状态没有按下
    }
    return 0;//否则返回无效值
```

1. 存储持续性：`static` 修饰的局部变量具有静态存储持续性，它在程序的整个运行期间都存在，而不是在函数调用结束时被销毁。
    - 例如，每次函数调用结束后，`static` 局部变量的值会被保留，下次函数调用时会继续使用上次修改后的值。
2. 初始化：只在第一次函数调用时进行初始化。
    - 假设一个函数被多次调用，但`static` 局部变量只会在第一次调用时被初始化为指定的值，后续调用不会再次初始化。
3. 作用域：作用域仍然局限在声明它的函数内部，在函数外部无法直接访问。

## 两种模式合二为一的思路

根据传入的mode值来强制使Key up为1

```c
uint8_t KEY_Scan(uint8_t mode)
{
    static key_up = 1//=1表示上一个状态为未被按下
    if(mode == 1)//如果mode为1
    {
        key_up = 1;//那么key强制为1.支持连续按。
    }
    if(key_up && KEY按下)//如果上个状态未被按下，并且现在KEY按下，那么就进入。
    {
        delay(10)//延迟10ms，消抖
       
        if(KEY按下)//确定按下
        {
            key_up = 0;//标记KEY按下
            return 有效值
        }
    }
    else if (KEY没有按下)
    {
        key_up = 1;//记录上个状态没有按下
    }
    return 0;//否则返回无效值
}

```

## 实现按键点亮对应LED灯

这里已经在头文件内定义了宏，

`#define KEY1 GPIO_ReadInputDataBit(GPIO_B,GPIO_PIN_11)//读取 GPIOB 11引脚的宏`

点灯图如下：

![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%201.gif)

key.文件如下

```c
#include "key.h"
#include "stm32f10x.h"

//初始化GPIO
//按键1 2是低电平检测。所以模式配置为上拉输入
void KEY_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//使能APB2总线的GPIOC 时钟
    
    GPIO_InitTypeDef GPIO_InitStructure;
    
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_0;//KEY 1  2 对应引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB,&GPIO_InitStructure);//初始化GPIOB 11  0引脚
    
}

//按键检测
uint8_t KEY_Scan(uint8_t mode)
{
    static uint8_t Key_up = 1;//初始化keyup = 1，未被按下
    if(mode == 1)
    {
        Key_up = 1;//如果启动了连续按下模式，那么就强制定义上一次状态为未被按下
    }
    if(Key_up && (KEY1||KEY2))//上一次未被按下，现在KEY1或2按下。那么就有效
    {
        Delay_ms(50);//去抖动
        Key_up = 0;//赋值为0,标记按下
        if     (KEY1)
        {
            return 1;
        }
        else if(KEY2)
        {
            return 2;
        }    
        }
    else if(KEY1 == 0 && KEY2 == 0)
    {
        Key_up = 1;//未被按下，那么赋值为1，标记未被按下。
    }
    return 0;
}

```

Key.h文件如下

```c
#ifndef __KEY_H
#define  __KEY_H

#include "stm32f10x.h"
#include "Delay.h"

//低电平有效，读取到低电平返回1
#define KEY1 (!(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11) ))//读取 GPIOB 11引脚的宏
#define KEY2 (!(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)  ))//读取 GPIOB 11引脚的宏

//初始化KEY引脚
void KEY_Init(void);

//按键扫描  1为支持连续按，0为不支持
uint8_t KEY_Scan(uint8_t mode);

#endif

```

LED.c文件如下

```c
#include "led.h"

//初始化LED
void LED_Init(void)
{
    //跑马灯引脚为PB 12 13 14 15,LED为低电平有效
    
        
    //F4的芯片在这里还需要配置上下拉电阻PuPd 以及 推挽或者开漏Otype
    
    //打开GPIOB的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);

    //定义GPIO_Init的第二个参数：结构体变量
    GPIO_InitTypeDef GPIO_InitStructure;                
    //↑在C99下不需要放到第第一行
    
    
    //下面的GPIO是分开配置的，其实可以写成A||B.这样就不用写那么多次了。这里我就不改了
    
    
    //PB12
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    //配置PC13的端口为推挽输出模式，速度为50MHz
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);//GPIO_Init，初始化GPIO B，PB12的GPIO
    GPIO_SetBits(GPIOB,GPIO_Pin_12);//设置GPIO为高电平。LED为熄灭
    //
    
   //PB13
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_13);
    
   //PB14
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_14);
    
    
   //PB15
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_15);
    
}

//熄灭LED
void LED_OFF(uint8_t num)
{
    if(num == 0)
    {
        return;
    }
    if(num == 1)
    {
        GPIO_SetBits(GPIOB,GPIO_Pin_12);
    }
    else if(num == 2)
    {
        GPIO_SetBits(GPIOB,GPIO_Pin_13);
    }
    else if(num == 3)
    {
        GPIO_SetBits(GPIOB,GPIO_Pin_14);
    }
    else if(num == 4)
    {
        GPIO_SetBits(GPIOB,GPIO_Pin_15);
    }
}

//点亮LED
void LED_ON(uint8_t num)
{
    if(num == 0)
    {
        return;
    }
    if(num == 1)
    {
        GPIO_ResetBits(GPIOB,GPIO_Pin_12);
    }
    else if(num == 2)
    {
        GPIO_ResetBits(GPIOB,GPIO_Pin_13);
    }
    else if(num == 3)
    {
        GPIO_ResetBits(GPIOB,GPIO_Pin_14);
    }
    else if(num == 4)
    {
        GPIO_ResetBits(GPIOB,GPIO_Pin_15);
    }
}

//反转LED
void LED_Flip(uint8_t num)
{
    if(num == 0)
    {
        return;
    }
    else if(num == 1)
    {
        if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_12) == Bit_SET)
        {
            GPIO_ResetBits(GPIOB,GPIO_Pin_12);
        }
        else
        {
            GPIO_SetBits(GPIOB,GPIO_Pin_12);
        }
    }
    else if(num == 2)
    {
        if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_13) == Bit_SET)
        {
            GPIO_ResetBits(GPIOB,GPIO_Pin_13);
        }
        else
        {
            GPIO_SetBits(GPIOB,GPIO_Pin_13);
        }
    }
    else if(num == 3)
    {
        if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_14) == Bit_SET)
        {
            GPIO_ResetBits(GPIOB,GPIO_Pin_14);
        }
        else
        {
            GPIO_SetBits(GPIOB,GPIO_Pin_14);
        }
    }
    else if(num == 4)
    {
        if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_15) == Bit_SET)
        {
            GPIO_ResetBits(GPIOB,GPIO_Pin_15);
        }
        else
        {
            GPIO_SetBits(GPIOB,GPIO_Pin_15);
        }
    }
}

```

LED.h文件如下

```c
#ifndef __LED_H //条件编译
#define __LED_H

#include "stm32f10x.h"

//初始化LED
void LED_Init(void);

//点亮LED
void LED_ON(uint8_t num);

//熄灭LED
void LED_OFF(uint8_t num);

//反转LED
void LED_Flip(uint8_t num);
#endif

```

# 5.[正点]MDK中寄存器地址名称映射的再理解

举个栗子就比较明白了。

比如（这里的外设是不准确的，具体要看手册里的。）

外设基地址为              `0x01000000`
APB1的外设基地址为`0x00100000`

- GPIOA外设是挂载在AHB1上的。
GPIOA地址为 `0x00110000`

APB2的外设基地址为`0x00200000`

- I2C外设是挂载在AHB2上的。
I2c的地址为   `0x00210000`

看图大概就是这样子

![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2010.png)

每一级往下都会有一个偏移量。是相对于他的母目录的地址的偏移量

# 6.[正点]时钟树系统的了解

## STM32（ARM）的时钟为什么要设置的那么复杂

为什么ARM的芯片不能像51单片机就一样，全部都弄成一个时钟呢？

1. 有利于省电
51单片机是很早之前比较广泛应用，当时对芯片的功耗高低的要求不高
而STM32作为新型的芯片，他的内核是Cortex - M3的内核。他对于功耗的要求就比较高。这里的高不是功耗要变高，而是对功耗控制的精度变高。不同的外设用不同的频率。因为频率越高。功耗也就越高
2. 不同外设的频率不相同
使用不同外设，如果用相同的频率。那么外设的抗干扰能力就会变弱。功耗也会变大。

## 分析时钟树的方法（这里是对F4系列芯片）

### 时钟分析方法

要分析之前，首先要知道**梯形符号**是什么意思.
梯形符号叫做**“选择器”**  他可以选择多个时钟的其中一条来输出

1. LSI 低速内部时钟
L - low低速  S  - speed 速度   I - interior内部
    
    频率为32KHZ，是内部的LC振荡器，不太稳定。一般是给独立看门狗做时钟的。（看门狗也需要使能看门狗的使能位。）
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2011.png)
    
2. LSE 低速外部时钟
    
    E  -  external 外部
    这里是我们外接的（低速）晶振时钟。它的稳定性就很高了。
    
3. `HSI` 高速内部时钟  16Mhz  。 内部的，不稳定
4. `PLLCLK` 锁相环时钟输出
有俩，第一个是主用的，第二个是专用的。 其中的xN是倍频器。  /P是分频器。 /Q是USB模块用的。/R主用的没用到。
    
    为什么要有一个专用的呢？因为对于I2S的时钟对频率要求非常高，所以是专用的。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2012.png)
    
    可以看到，主PLL锁相环输出的系统时钟。可以经过选择器。
    AHB与分频器给很多的外设
    AHB的信号，又能经过APBX的与分频器，又能产生很多时钟。
    APBX就是给相关外设用的。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2013.png)
    
5. `HSE` 高速外部时钟(可以接4-26M的外部时钟)
6. `MCO1` 和 `MCO2`  这两个是可以经过分频器和选择器来输出到芯片引脚上的

### 总结：

1. STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL.
    1. HSI是高速内部时钟，RC振荡器，频率为16MHZ，精度不高。可以直接作为系统时钟或者用作PLL时钟输入。
    2. HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~26MHZ。
    3. LSI是低速内部时钟，RC振荡器，频率为32KH2，提供低功耗时钟。主要供独立看门狗和自动唤醒单元使用。
    4. LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTCPLL为锁相环倍频输出。STM32F4有两个PLL
        1. 主PLL(PLL)由HSE或者HSI提供时钟信号，并具有两个不同的输出时钟
            1. 第一个输出PLLP用于生成高速的系统时钟(最高168MHz)
            2. 第二个输出PLLQ用于生成USBOTGFS的时钟(48MHZ)，随机数发生器的时钟和SDIO时钟。
        2. 专用PLL(PLLI2S)用于生成精确时钟，从而在12S接口实现高品质音频性能

2. .系统时钟SYSCLK可来源于三个时钟源:

1. HSI振荡器时钟
2. HSE振荡器时钟
3. PLL时钟

### 常用时钟配置寄存器

- RCC时钟控制寄存器 `RCC_CR`
    
    主要用来配置、使能时钟源。就绪时钟源的
    
- RCC PLL配置寄存器  `RCC_PLLCFGR`
    
    是用来配置PLL锁相环输出中的P、Q、R等值。
    
- RCC 时钟配置寄存器 `RCC_CFGR`
    
    用来配置分频系数以及时钟源。（梯形以及方块里的/M的配置）
    
- RCC AHB**X**外设时钟使能寄存器 `RCC_ AHBXENR`
    
    使能一些外设的时钟
    
- RCC  APB1、APB2 外设时钟使能寄存器 RCC_APBXENR
    
    使能一些外设的时钟
    

# 7.[正点]SystemInit.c时钟系统初始化文件了解

在系统初始化之后，是先调用Systemlnit函数，然后才调用main函数的。（这点在.s的启动文件哪里，可大概看到汇编指令是先执行sys再执行main的）

这个文件会打开时钟以及复位一些东西，具体可以去手册的RCC和SystemInit.c文件中对应的去看。把16进制翻译为2进制后，找到寄存器的对应位就OK。这样就知道这些是什么作用了。

这个建议新手不要改

# 8.[正点]Systick定时器

## Systick定时器基础知识了解

- Systick定时器，是一个简单的定时器，对于CM3.CM4内核芯片，都有Systick定时器
- **Systick定时器常用来做延时，或者实时系统的心跳时钟**。**这样可以节省MCU资源，不用浪费一个定时器**。比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟:
- Svstick定时器就是系统滴答定器一个**24 位的倒计数定时器**，
计到0时，将从RELOAD寄存器中自动重装载定时初值。只要不把它在SvsTick控制及状态寄存器中的使能位清除，就永不停息，**即使在睡眠模式下也能工作:**
- SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常(异常号:15)
**意思就是它能够产生中断。**
Systick中断的优先级也可以设置

## Systick定时器的四个寄存器

- SysTick控制和状态寄存器    -   `CRTR`
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2014.png)
    
    可以配置使能、是否产生中断（异常请求）、配置内外部时钟源
    以及在一次循环之后。可以读取的位段16的值。（读取后复位）
    
    配置的函数：`SysTick_CLKSourceConfig();`
    
- SysTick 自动重装载初值寄存器    -   `LOAD`
放重装时放的值
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2015.png)
    
- SysTick  当前值寄存器     -  `VAL` 
把重装值复制过来，然后每个时钟周期-1
减到零就再次重装
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%2016.png)
    
- SysTick   校准值寄存器
    
    不太重要。
    

## Systick相关函数

固件库中在 misc.c文件中

`SysTick_CLKSourceConfig();`   时钟源选择  

`SysTick_Config(uint32_t ticks);` 初始化Systick，时钟为HCLK。并开启中断

SYstick中断服务函数

`void SysTick_Handler(void);` 

## 尝试使用Systick写一个延时函数

1. 把定义好Systick的重装值。
    
    这里使用到了中断与Systick的 `LOAD` 寄存器
    
    ```c
    // 延时函数初始化
    void Delay_Init(void)
    {
        // 配置 SysTick 为 1us 中断一次
        if (SysTick_Config(SystemCoreClock / 1000000))
        {
            while (1);  // 配置错误，进入死循环
        }
    }
    ```
    
    `SysTick_Config`是SysTick的时钟源选择函数。
    起内部的代码是
    
    ```c
    static __INLINE uint32_t SysTick_Config(uint32_t ticks)
    { 
      if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                                   
      SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
      NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
      SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
                       SysTick_CTRL_TICKINT_Msk   | 
                       SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
      return (0);                                                  /* Function successful */
    }
    ```
    
    在判断是否超过最大值后，这个函数会把你传入的值放到SYStick的LOAD寄存器（重装寄存器）中。
    然后设置优先级为最高
    并且将VAL寄存器（当前值寄存器）置零。
    噔噔蹬蹬….
    
    `SystemCoreClock` 是 STM32 标准库中定义的一个全局变量，用于表示系统的核心时钟频率。使用了条件编译的命令。这里默认为F1的72M
    
    那么`SysTick_Config(SystemCoreClock / 1000000)` 的意思就是设置系统滴答定时器的重装值为为7200（72 000 000000/1000000）。
    
    因为晶振的速度为72M，也就是一秒钟有72M个高电平。
    
    所以晶振震荡7200次花费的时间就是1us。
    
    所以可以这样去判断
    
    ```c
    // 延时函数
    void Delay_us(uint32_t us)
    {
        TimingDelay = us;
        while (TimingDelay!= 0);
    }
    
    // SysTick 中断处理函数
    void SysTick_Handler(void)
    {
        if (TimingDelay!= 0)
        {
            TimingDelay--;
        }
    }
    ```
    
    其中的中断函数`void SysTick_Handler(void)`，是库函数固定的，必须要用这个名字。他是SysTick的固定中断服务函数。
    
    `void Delay_us(uint32_t us)` 是定义的us函数
    
    举例子说，想`Delay_us` 函数中传参：50.
    
    那么全局变量`TimingDelay` == 50
    
    然后就会进入到`while (TimingDelay!= 0);` 命令中一直等待。此时就在等待中断处理函数把全局变量`TimingDelay` 减为0.然后跳出函数。此时程序就能继续运行了。 
    
    在中断处理函数中，每当重装值7200 减 到 0 之后。就会触发一次中断，（也就是执行一次 `SysTick_Handler()`函数。）全局变量`TimingDelay`就会减一。当他捡到0之后就不会再减了。
    
    要实现1ms延时。也很简单。只需要把传入的值x1000就OK啦
    
    ```c
    // 毫秒级延时函数
    void Delay_ms(uint32_t ms)
    {
        Delay_us(ms * 1000);
    }
    ```
    
    这次用这个Delay函数来实现一下闪烁灯试试.完全Ok。
    
    ![Untitled](STM32-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%202.gif)
    
    (如果在编译的时候报错，根据报错信息。大概率要去stm32f103x_it.h找到`void SysTick_Handler(void)`函数然后注释掉。不然会出现多次定义。头文件。)
    
    ```c
    int main()
    {
    
        KEY_Init();//初始化KEY
        LED_Init();//初始化LED
        Delay_Init();//初始化延时函数
        
        while(1)
        {
            LED_ON(1);
            Delay_ms(500);
            LED_OFF(1);
            Delay_ms(500);
        }
    }
    ```