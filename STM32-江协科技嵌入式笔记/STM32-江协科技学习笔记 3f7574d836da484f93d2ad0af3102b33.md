# STM32-江协科技学习笔记

介绍

这篇文章是我入门嵌入式的文章，有些理解可能不足。

是看江协的视频，板子是STM32F103C8T6最小系统板。

这些是我在学习STM32F103C8T6的过程中自己的学习过程，以及练习和个人笔记。

正在更新，

**大家可以在[我的gitee仓库](https://gitee.com/Xiao____liu/learn-STM32) 中下载笔记源文件、梁山派资料等**

**笔记源文件可以在Notion中导入**

# 1.创建基于标准库的工程模板

## 1.解压库函数的压缩包并打开

库函数为：`STM32F10x_StdPeriph_Lib_V3.5.0`，这个可以去官网下载。

解压后文件夹内容如下

- Libraries是库函数的文件
- Project是官方提供的工程示例和模板
- Utilities是官方做的一个小电路板，存放的用来测评stm32的程序
- Release_Notes.html是发布文档
- stm32f10x_stdperiph_lib_um.chm为库函数使用手册

## 2.建立工程模板，尝试使用寄存器/标准库来点灯

**本章建立了工程模板**。**并尝试用寄存器和库函数来进行点灯操作**

建立工程模板是为了配置好STM32的环境，并且方便下次去建立工程。不用每次都新建一次。

1. 建立工程文件是为了方便管理。可以起名为`STM32Project`
2. 在Keil上新建工程，起名后  选择芯片型号（这里为STM32F103C8）

### 一、添加Start启动文件夹

1. 新建Start文件，用来存放STM32的启动文件，STM32运行时会先运行它们
    
    启动文件的存放位置位于库函数的压缩包中的Libraries文件中。下面的位置可以参考用
    
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm`
    
    **我们把这里面的所有文件都粘贴到Start文件中。**
    
    往回走，可以在这个目录下找到一些头文件
    
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\**DeviceSupport**\ST\STM32F10x`
    
    - stm32f10x.h  -  STM32寄存器外设描述文件，是用来描述stm32有哪些寄存器，和他对应的地址
    - system_stm32f10x.c    -    这两个`system_stm32f10x`文件主要是用来配置时钟的（STM32的72MHZ主频就是在这里配置的）
    - system_stm32f10x.h    。
    
    **上面三个同上，也是全部放到Start文件中**
    
    因为STM32是内核和内核外围的设备组成的，并且内核寄存器描述和外围寄存器描述是不在一起的，所以要添加内核寄存器的描述文件
    
    这次就不是打开`D**eviceSupport`** 文件了，而是打开内核的**`CoreSupport`**文件
    
    - core_cm3.c  -  这两个就是内核的寄存器描述文件.h以及配置文件.c
    - core_cm3.h
2. Keil添加启动文件Start。`.s`的启动文件只需要添加一个。但他有分类
    
    
    所以我们选择`_md.s`后缀的文件
    
    添加后再把其他的.c  .h后缀的文件都添加进来（要选择筛选为ALL，否则看不全）
    
3. 在工程选项中添加文件的路径，否则找不到。
并且这样也有利于移动文件，因为添加后工程是以目录所在的文件位置去找文件，而不是使用绝对路径去找。可以很方便的打包工程发给别人
    1. 打开魔术棒，在C/C++选项中找到Include Paths的框框，点三个点找到Start的文件夹。然后确定。

### 二、添加User用户文件夹

1. 在工程模板的文件夹下添加User文件夹，用来存放用户写的代码
2. 在Keil软件的Start的上一个目录Target 1上右键，点击添加组。然后重命名为Start。
并在魔术棒→  C/C++中，添加好头文件路径 Include Path 
3. Keil软件上右键Start添加新文件，选择.c输入ain.c文件然后选择存放路径到User文件中，否则会默认放到文件夹外的工程目录中。
    
    （这里我已经在魔术棒上设置好Tab=4个空格和显示空格等配置了。）
    （并且魔术棒按钮的Target块中选择的是ARMCode编译器为v5.06）
    （在扳手工具处已经设置字号为14，编码格式为：GB2312）
    
4. 在里边输入
    
    ```c
    #include "stm32f10x.h"  //头文件
    
    int main()
    {
        while(1)
        {
        
        }
    }
    //注意最后一行得多一行空格，不然编译会报错。
    ```
    
    此时编译（编译分为全局编译和单文件编译，全局编译是对所有文件编译，单文件则是对当下的文件进行编译。这里先选择单文件就够了）就可以看到0错误0警告。
    
5. 把STINK和系统板插好，然后连接电脑。
- 3.3V对应3.3V
- GND对应GND
- SWDIO对应SWDIO
- SWCLK对应SWCLK
1. 点击魔术棒选择Debug，设置Use为STink调试器（ST-Link Debugger），然后点击右边的设置按钮。在flash下载的选项中，把Reset and Run 勾选上，这样每次下载程序后会自动复位并执行，不需要按复位按键了
    
    （这里我已经下载好虚拟串口的驱动CH340了，不下是发现不了设备的）
    
2. 编译一下，可以看到0警告0错误

### 三、尝试用寄存器点亮LED灯

**当弄到现在，创建好User文件夹对于寄存器开发者来说，已经建立好工程模板了。**

> **可以先尝试一下寄存器点灯**
> 

这里我点的灯位于GPIOC，

寄存器点灯只需要配置三个寄存器。

1. **首先是配置RCC寄存器，使能GPIOC的时钟，**
要使能GPIOC的时钟。而GPIO是挂载到APB2的总线上的。
    
    打开STM32F10xxx参考手册（中文）手册后可以看到IOPC是在RCC_APB2ENR总线上（偏移地址：0x18）的第4位控制。并且下面有说明这一项为1就开启。
    
    所以把这一项写1就可以开启他的时钟了。
    
    整个寄存器的2进制数据换成16进制就是0 0 0 0    0 0 1 0
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled.png)
    
    **所以写上代码`RCC->APB2ENR = 0x00000010;`就可以打开GPIOC的时钟了。**
    
2. 然后第二个寄存器，要配置PC13的端口的模式
    
    在手册中的通用和复用I/O中可以找到GOIO寄存器的一小节。在里面找到**端口配置高寄存器（GPIOx_CRH）**的一小节。
    (0-7的前八位是在低寄存器里，8-15是在高寄存器里配置)
    其中的CNF13 和MODE13就是用来配置端口PC13的
    
    这里我们需要将端口配置为 通用推挽输出模式也就是CNF13的两位要为**00**，
    MODE则是设置为输出模式，最大速度为50MHZ,也就是MODE两位要为**11**
    
    最后按照16进制，把32位二进制位转换为16进制的数字
    也就是把0 0 3 0   0 0 0 0 
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%201.png)
    
    **所以写上代码`GPIOC->CRH = 0x00300000;`就配置PC13口为推挽输出模式，速度为50MHz了**
    
3. 下一步就是配置端口输出数据寄存器
    
    在手册中的通用和复用I/O中可以找到GOIO寄存器的一小节。
    在里面找到**端口输出数据寄存器（GPIOx_ODR）**的一小节。
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%202.png)
    
    这一位写一就是把PC13的输出设置为高电平了。
    
    把这32位2进制换算为16进制，就是0 0 0 0   2 0 0 0 
    
    **所以写上代码`GPIOC->ODR = 0x00002000;`就配置PC13口为高电平**
    
    因为这个板子的灯是低电平点亮，所以配置为全0就能点亮灯了**`GPIOC->ODR = 0x00000000;`**
    下边那个灯就是我点亮的。
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled.jpeg)
    
    > 可以看到寄存器点灯十分的麻烦，得去手册查寄存器。而寄存器那么多，根本不可能记得完。并且我刚才点灯是把除了PC13之外的位都设置成了0。,这样会影响其他端口的正常配置，如果要不影响的话还得用&=或者|=。就会更加麻烦。所以寄存器的操作方式，虽然代码简洁，但是操作起来很不方便
    
    下面我就要去学习库函数的使用，来用库函数点灯！！
    > 

### ***、尝试用库函数来点亮LED灯

### 四、添加Library文件

**本章添加了库函数到Library文件，并在Keil软件中定义了库函数头文件。**

Library是用来存放库函数的，让我们可以使用。

1. 在工程目录新建Library的文件夹。
2. 添加库函数到新建的Library文件
    
    库函数位于库函数压缩包的目录为：**`\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\src`** 中了。其中`STM32F10x_StdPeriph_Lib_V3.5.0` 为STM公司推出的标准外设库。
    
    其中的文件就是库函数的源文件了。
    
    misc.c  为内核的库函数。其余的都是内核外的外设库函数。
    这里就Ctrl+A全选，全部复制到Library文件夹中
    
    然后再打开固件库的inc文件夹，目录就在上一级。
    `\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver\inc`
    
    这个文件夹中放的是库函数的头文件，也把他复制到Library文件夹中。
    
3. 接着回到keil软件，在target 1 处右键，添加组，重命名，然后添加文件到组
    
    > 但是到这里，对于库函数来说还是不能直接使用的，需要再添加三个文件
    它位于固件库目录的：**`\STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template`**
    > 
    
    可以看到几个文件
    
    - stm32f10x_conf  -  用来配置库函数头文件的包含关系，还有用来参数检查的函数定义，这是所有库函数都需要的
    - 剩下的两个it后缀的是用来存放中断函数的
    
    把这三个文件放到User的目录中。接着在keil软件的User组中添加这三个文件。**并在魔术棒→  C/C++中，添加好头文件路径 Include Path** 
    
4. 完成后，就需要添加库函数的头文件了。
    
    先对`#include "stm32f10x.h"` 的`stm32f10x.h` 右键，选择打开`stm32f10x.h` 滑到最下边可以看到这样一段代码：
    
    ```c
    #ifdef USE_STDPERIPH_DRIVER
      #include "stm32f10x_conf.h"
    #endif
    ```
    
    这是C语言中的条件编译语句，意思是如果我定义了`USE_STDPERIPH_DRIVER`。下面的这个`#include "stm32f10x_conf.h"`才有效
    
    这需要我们点击魔术棒按钮，在C/C++的选项中，在Define框框中输入`USE_STDPERIPH_DRIVER` 这样才能包含标准库函数。
    
    （记得把每个组（文件）的路径添加好头文件路径 Include Path，在魔术棒的C/C++ 中）
    
    可以在KEil软件看到。
    User中的文件，我们是可以修改的，而Start和Library文件中的东西都带有小钥匙
    是改不了的。我们可以点击魔术棒旁边的小箱子来拖动挑中左边的组的排序位置。
    
    比如把User放到最下边，其他放上边，这样的话平时不用就可以收起来。
    
    下面再编译一下就可以看到成功了。
    （单文件编译，如果新添加了文件会默认使用全局编译一次。所以比较慢）
    

### 五、使用库函数进行点灯操作

**本小节使用库函数进行点灯。**

库函数本质还是配置寄存器，不过是间接的了。

1. 第一步还是使能GOIOC的时钟
它位于APB2的外设上。
    
    库函数中用来开启时钟的函数是`RCC_APB2PeriphClockCmd` 
    大概翻译一下就是RCC_APB2  外设  时钟  命令（控制）
    
    输入完后会提示出来这个函数要输入两个参数。
    
    **可以在编译后按F12或者右键跳到函数定义来看他的参数需要填什么，都会有介绍。**
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%203.png)
    
    简介中会说，这个函数是让APB2的时钟使能或者失能的。他的参数可以是下面这些。
    
    **我们这里用的是`RCC_APB2Periph_GPIOC` 这一项，然后填写到函数的第一个参数就OK**
    
    **第二个参数是`ENABLE` 使能。**
    
    **这样就可以使能GPIOC的时钟了。**
    
    通过F12下这个函数，来查看这个函数的内部代码。其实他只是包装了一下。实际上还是配置寄存器的。
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%204.png)
    
2. 第二步还是配置端口的模式。
    
    这里用的库函数是`GPIO_Init`，F12查看定义，可以知道他的两个参数
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%205.png)
    
    第一个参数是选择GPIO。x可以是A-G中的数字
    所以第一个参数就是GPIOC。
    
    第二个参数是一个`GPIO_InitTypeDef` 的结构体**的指针（是指针！）**。我们需要先定义一个结构体。结构体的名字根据官方的推荐，最好叫`GPIO_InitStructure。`
    
    代码：`GPIO_InitTypeDef GPIO_InitStructure;`
    
    然后复制结构体的名字，用 `.`  操作符来配置结构体内部的变量。
    
    ```c
        GPIO_InitTypeDef GPIO_InitStructure;
        GPIO_InitStructure.GPIO_Mode = 
        GPIO_InitStructure.GPIO_Pin = 
        GPIO_InitStructure.GPIO_Speed = 
    ```
    
    > 这里可以现在Mode的一行按F12 ，跳转到Mode参数的定义。
    > 
    
    他说：Mode的值在`GPIOMode_TypeDef`（这是一个枚举变量）里可以找到。那么就可以在当前文件Ctrl+F搜一下。找到GPIOMode_TypeDef这个枚举变量的位置。
    这里我们用到的是`GPIO_Mode_Out_PP` ：通用推挽输出。
    然后把这个参数放到Mode = 后就可以了。
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%206.png)
    
    > 下面就是配置GPIO_Pin的参数了,
    > 
    
    在使用F12跳转的时候，会显示一个框，这是因为他的定义后很多个。
    这里需要的是member这一项，双击就可跳转过去了。
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%207.png)
    
    （其实还是刚才GPIO_Mode跳转过去的那个位置）
    
    他说Pin的值在`GPIO_pins_define`（这是一个枚举变量）里可以找到
    
    仍然是Ctrl+F搜一下。
    
    可以看到这里是#define的宏定义列表
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%208.png)
    
    这里我们需要用到的是GPIO_Pin_13
    
    仍然是复制粘贴过去
    
    > Speed的参数也是同理
    > 
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%209.png)
    
    这里选择`GPIO_Speed_50MHz`
    
    致此，我们定义的结构体变量`GPIO_InitTypeDef GPIO_InitStructure;`的参数就配置完全了。
    下面就可以把结构体变量的**地址（是传地址！！）**放到配置GPIO模式的函数`GPIO_Init` 的第二个参数中了。
    
    ```c
        //配置PC13的端口为推挽输出模式，速度为50MHz
        GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        
        GPIO_Init(GPIOC,&GPIO_InitStructure);//GPIO_Init，配置GPIO模式
    ```
    
3. 第三步：配置GPIO口为高/低电平
    
    这里用到的函数是
    `GPIO_SetBits`  - 设置GPIO为高电平
    `GPIO_ResetBits`  -  设置GPIO为低电平
    
    参数则都是GPIOx，GPIO_Pin_x
    要看定义也是同上F12
    
4. 编译！！
    
    代码如下，如果编译的时候报错：
    
    ```c
    User\main.c(15): error:  #268: declaration may not appear after executable statement in block
    GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
    ```
    
    他的意思这一行的声明位置。C 语言要求变量声明通常应在可执行语句之前。这违反了 C 语言的语法规则，想让我把`GPIO_InitTypeDef GPIO_InitStructure;` 放到第一行声明。我能听他的？
    
    **解决办法就是：在魔术棒→ C/C++处勾选C99Mode（C语言的C99标准）**，这样就不会报错了。
    
    ```c
        //库函数点灯
        
        //打开GPIOC的时钟
        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
        
        //配置PC13的端口为推挽输出模式，速度为50MHz
        GPIO_InitTypeDef GPIO_InitStructure;                //定义GPIO_Init的第二个参数：结构体变量
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        
        GPIO_Init(GPIOC,&GPIO_InitStructure);//GPIO_Init，配置GPIO模式
        //设置PC 13为低电平。点灯。
        GPIO_ResetBits(GPIOC,GPIO_Pin_13);
    ```
    
    点灯如下：
    
    ![Untitled](STM32-%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203f7574d836da484f93d2ad0af3102b33/Untitled%201.jpeg)